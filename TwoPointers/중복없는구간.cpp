/*
영진좌 추천문제. 중복없는구간 검색해서 나온 문제 생각해보기. 


문제
n개의 숫자가 주어지고, 이 중에서 r개의 연속된 숫자를 선택했을 때, 이 연속 부분 내에는 숫자가 중복되지 않기를 원한다. 
예를 들어, 다음과 같이 10개의 숫자에서 3개의 연속된 숫자를 선택할 수 있다.

1	3	1	2	4	2	1	3	2	1
	↑      ↑

이렇게 선택을 하면(3,1,2), 선택된 숫자들 사이에서는 중복이 존재하지 않는다. 
r의 최댓값을 구하는 프로그램을 작성하시오. 위의 경우, (4, 2, 1, 3)을 선택하면 되므로 r의 최댓값은 4이다. 
r이 5 이상이 될 경우, 중복 없이 연속 부분을 선택하는 것이 불가능하다.

입력

첫째 줄에는 숫자의 개수 n이 주어진다. ( 1 ≤ n ≤ 100,000 ) 둘째 줄에 n개의 숫자가 주어진다. 각 숫자는 항상 1보다 크거나 같고, n보다 작거나 같다.

출력
r의 최댓값을 출력한다.


1. NlogN풀이
정답이 될 수 있는 후보는 1 ~ N. k=[1,N]일 때,
길이가 N인 배열에서 길이가 K인 중복없는 구간이 있는지  판단하는 이분탐색을 진행한다면,
이분탐색에 logN, K가 주어졌을 때 전체를 훑으면서 길이가 K인게 되는지 판단하면 된다.
그런데 길이가 K인게 되는지 판단하는 것이 되려면 
1 3 1 2 3 2 1 3 2 1에 대해서 
1 3 1 2까지 보고
  2 1 2 3 까지 보고
    1 2 3 2까지 보고 하면서 
앞에서 하나 빼고 뒤에서 하나 더하고 이렇게 진행되어야 할 것이다.
left와 right를 가리키는 포인터를 만들고 left + k = right라고 정의한 느낌으로.

2. O(N) 풀이
Two Pointers :
1 3 1 2 3 2 1 3 2 1에 대해서
L R 이라고 두고 시작한다.
1과 3을 만났다고 체크하고 최대 길이를 갱신한다.
R에서 만난 1은 이미 등장했기 때문에, 이번에 만난 1이 나올 때까지 L을 올린다.
L은 항상 R보다 작으며 배열이 1 1인 경우에는 L == R이 될 때까지 L을 당겨야 한다.

*/

#include <iostream>
using namespace std;
int arr[10] = { 1,3,1,2,4,2,1,3,2,1 };
bool visited[10] = { false, };
int main(void) {
	
	int ans = 0;
	int L = 0, R = 1;
	visited[arr[L]] = true;
	while (R < 10) {
		int added = arr[R];
		if (!visited[added]) visited[added] = true;
		else {
			while (L<=R) {
				int deleted = arr[L];
				visited[deleted] = false;
				L++;
				if (deleted == added) {
					visited[added] = true;
					break;
				}
			}
		}
		cout << L << "," << R << "\n";
		ans = ans < R - L + 1 ? R - L + 1 : ans;
		R++;
	}
	cout << ans << "\n";
	return 0;
}