# 네이버 공채 1번 

문제 : 옳바른 이메일 형식인지 판단
데이터 : ["niklasjang@naver.com" , ... ]
풀이 : [구간0]@[구간1].[구간2]로 나누고 앞에서부터 쭉 읽는다.
int section = 0;
for(int i=0; i<s.length(); i++){
    if(s[i] == '@'){
        if(section == 0) section = 1;
        else section = -1;
    }else if(s[i] == '.'){
        if(section == 1) section = 2;
        else section = -1;
    }
}
if(section == -1) return false;
else return true;

# 네이버 공채 2번

문제 : 1~6으로 구슬을 굴렸을 때 가장 아래 쪽까지 떨어지는 번호 찾기
# : 아래로 떨어짐
< : 왼쪽으로 이동
> : 오른쪽으로이동
* : 처음 만나면 아래로, 두 번째 만나면 걸려서 더이상 진행 하지 못함

데이터 :
1 2 3 4 5 6
# # # # # #
< > < < > >
* * # # # #
* # # # # #
int r=0, c=0;
bool stuck = false;
while(true){
    if(map[r][c] == '#'){
        r += 1;
    }else if(map[r][c] == '<'){
        c -= 1;
    }else if(map[r][c] == '>'){
        c += 1;
    }else if(map[r][c] == '*'){
        if(!stuck) stuck =  true;
        else return false;
    }
}

# 네이버 공채 3번 : OS시간에 배운 Shortest Job First

아래 문제랑 거의 똑같음 
https://programmers.co.kr/learn/courses/30/lessons/42627#

풀이 : vector, priority_queue 또는 set(operator<오버라이딩)
정답 코드 : 
https://github.com/niklasjang/problem_solving/blob/master/PriorityQueue/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_42627_%EB%94%94%EC%8A%A4%ED%81%AC%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC.cpp

# 영진좌 공부법
1. 학교 자료구조, 알고리즘, 문해기 수강
2. 어찌어찌 알고리즘잡스랑 이미 알고 있던 상황
3. 작년 6월에 알고리즘잡스에서 알바 제의
4. 1달동안 알고리즘잡스에서 가르칠 문제 혼자 품
    - 쉬운 문제(별찍기등) 하루  50개! 목표!! (일주일밖에? 성공못함)
    - 시작할 당시 백준 전체 100등이 푼 문제 무작정 따라풀기 (지금은 비추천)
    - 지금은 solved.ac있어서 난이도 보고  풀면ㄷ 됨. 
    - 개념을 모르겠으면 https://www.acmicpc.net/user/kkss2889 이 사람 블로그에서 쉬운 알고리즘부터 찾아보길 추천
5. 7월부터 알바중 (우리한테 제시한 (인당 2시간 3~5만원/ 3명 7~9만원)은 학원알바보다 조금 싼 가격)


# 라인 인턴 면접 문제 1
유클리드 좌표계(그냥 좌표가 int라는 뜻)에서 직사각형의 가로 세로 길이 a, b로 넓이 a*b를 구할 수 있다.
넓이 S가 주어졌을 때 가로 a, 세로 b 중 |a-b|가 가장 작은 a,b를 구하기
풀이 : O(sqrt(n))
for(int i=1; i<= sqrt(n); i++){
    v.push_back(i);
    if(i * i != n) v.push_back(n/i);
}

# 라인 인턴 면접 문제 2
n!가 몇 개의 2로 나누어 떨어지는지 구하기
= n!를 소인수 문해했을 때 2가 몇 개 나오는지 구하기
풀이 : O(logN)
이건 만나서 설명해줌. 나도 모르겠어서 설명들음

# 라인 인턴문제 코테 문제 6문제
위에서 언급한 네이버 문제보다 훨씬 어렵

# 네이버 면접 대비 공부 방법
면접이 1시간으로, 문제해결능력은 최대 20분정도 물어볼 것으로 예상되서 손코딩이나 입코딩 형태로 출제될 것임을 예상.

1. 이분탐색 설명하기.
    - 이분탐색은 정렬된 배열에서 key값을 찾을 때 O(logN)으로 찾을 수 있는 알고리즘 입니다. 
    - 여기서 key값은 문제를 풀기 위한 최적해가 아니라, 최적해일 가능성이 있는 값입니다. 이분탐색 알고리즘은 최적해를 구하는 알고리즘이 아닌,
    어떤 값이 최적의 해인지 true/false를 판단할 수 있는 문제에 사용합니다.
    - 다음은 정렬의 관점에서 설명하는 알고리즘입니다. 가장 왼쪽을 가리키는 left와 가장 오른쪽을 가리키는 right를 설정합니다. 그리고 이 둘의 가운데인 mid를 설정합니다. 
    - lower_bound는 key보다 **같거나 큰** 가장 작은 값을 찾는 알고리즘입니다.v[mid]와 key를 비교해서 전자가 **작을 때** left = mid+1이고 아니라면 right = mid입니다. 
    - upper_bouond의 경우 key보다 **큰** 값 중 가장 작은 값을 찾는 알고리즘입니다. v[mid]와 key를 비교해서 전자가 **같거나 작을 때** left = mid+1이고 아니라면 right = mid입니다.
2. 해시 알고리즘(말로 설명하기 준비)
    - Direct Addressing Table : {key : value} 쌍에 대해서 value를 arr[key]에 저장하는 방법
        - 삽입은 arr[key]에 삽입하면 되서 O(1)
        - 삭제는 arr[key] = null이므로 O(1)
        - 탐색은 arr[key] 이므로 O(1)
        - 단점 : 매우 빠르지만 1~N까지의 배열이 필요하므로 데이터가 듬성듬성 있을 때는 메모리 낭비가 심하다.
    - Hash Table
        - **chaining hash**
        - {key : value}쌍에 대해서 key를 어떤 함수의 입력으로 넣고, 이 함수의 출력을 index로 사용하는 방식
        - 여기서 어떤 함수를 해쉬 함수라고 부른다. 해쉬함수는 입력으로 key를 받아서 [0,key-1] 범위의 값을 출력한다.
        - 임의의 크기의 입력을 배열만큼의 길이로 축소시키는 것이다.
        - 단점 : key 1과 12에 대해서 해시함수가 %11이라면 연산 결과는 1로 같다. 따라서 하나의 key에 여러 개의 value가 존재하는 충돌이 발생한다.
        - 해결 : 최초로 h(k) 위치에 저장되는 데이터를 시작으로, 이후의 h(k)값이 출력되는 데이터는 모두 연결리스트의 형태를 취한다. 
        - 삽입 : arr[h(k)].push_back(arr[key]) : O(1)
        - 삭제 : arr[h(k)] = null : O(1)
        - 탐색 : for(int i=0; i< arr[h(k)].size(); i++) : 연결리스트의 길이만큼 : 최악의 경우 모든 h(k)가 같을 때 선형시간.
        - 적재율 : 최악의 선형 탐색시간은 너무 하드한 경우이고, 일반적으로는 N개의 데이터를 K개의 key에 대해서 저장하면 평균 N/K씩 연결리스트에 저장된다. 데이터가 많을 수록, K가 적을 수록 충돌이 많이 일어난다.
        - 구현 : 가장 일반적인 구현은 %M 연산을 해시함수로 사용하는 것이다.
        - M이 해시테이블의 성능에 지배적인 영향을 미치는데, 보통 Key의 3배에 해당하는 M을 사용한다. key*3 = M일 때 적재율 30%까지는 충돌이 잘 일어나지 않는다고 한다.
        - M을 2^n형태로 사용하는 것은 지양해야 한다. M = 2^2인 경우 00001100(2)과 11001100(2)의 MOD는 100으로 같은 경우가 많이 존재하기 때문이다.
        - 최적의 M 값은 Key*3에 가까우면서 2^N의 형태에 가까운 '소수'라고 한다.
    - **Opening Addressing**
        - value 값을 key로 사용하는 방식이다.value 값을 h(x)의 input을 넣고 그 결과의 인덱스 자리에 value를 넣는다. arr[h(value)] = value;
        - 만약 충돌이 일어나면 바로 다름 칸에 삽입을 시도하다가, 충돌이 일어나지 않는 곳에서 삽입된다.
        - h(k,i) = (k+i) mod M 이라고 표현할 수 있다. K=value이고, i는 0에서 시작해서 충돌할 때마다 +1된다. 배열의 끝에서 충돌하면 제일 처음으로 돌아와서 자리를 찾기 위함이다.
        - 문제점 : primary clustering : 데이터가 배열의 한 부분에만 밀집되서 저장되는 특정을 보인다. 이는 탐색에 악영향을 준다.
        - 해결법 : **Quadratic probing** : 해시함수를 2차식의 형태로 만든다.
            - h(k,i) = (h'(k) + c1\*i + c2\*i^2) mod M // 충돌시 한 칸씩 이동하는 것이 아니라, c1\*i + c2\*i^2칸씩 이동한다. 
            - 예를 들어서 h(k,i) = (k + i^2) mod M이라고 해시함수를 만들어서 사용하면 된다.
            - 문제점 : 하지만 h'(k)값이 같을 경우 그 이후의 해쉬값들도 모두 동일한 값으로 계산되어 충돌이 반복적으로 일어난다. (secondary clustering)
        - 해결법 : **Double Hashing**
            - h1(k) = k mod m
            - h2(k) = k mod m2
            - h(k,i) = (h1(k) + h2(k)*i) mod m
3. 해시 알고리즘의 연장선, 라빈카프
    - https://m.blog.naver.com/PostView.nhn?blogId=kks227&logNo=220927272165&proxyReferer=https%3A%2F%2Fwww.google.com%2F
    - 문자열 S의 길이가 N, 문자열 W의 길이가 M일 때 S에서 W를 찾는 완탐은 O(NM)입니다.
    - 문자열 S에서 길이가 M인 구간 S'라고 했을 때, S'와 W가 같은지를 비교하는 O(M)을 안해도 되는 경우를 거를겁니다.
    - O(M)를 진행하지 않아도 되는 경우는 S'와 W의 해시값이 다를 때입니다. S'와 W의 해시값이 같으면 O(M)만에 하나하나 비교해서 같은지 판단합니다.
    - 그러면 S' 구간을 정해서 이를 해시로 바꾸는 과정에서의 복잡도 K라고 할 때 사실 O(NMK)입니다. 그런데 해시가 같은 경우는 많이 없기 때문에 O(M)를 진행하는 횟수가 매우 작다는 가정하에 O(N)가 됩니다. 해시로 바꾸는 과정의 복잡도는 O(1)만큼으로 작게 한다는 가정입니다.
    - 그러면 복잡도 K를 O(1) 만드는 방법 설명을 하겠습니다.
    - H[i] = S[i]\*2^(m-1) + S[i+1]\*2^(m-2) + ... + S[i+m-2]*2^1
    - S[i]를 아스키코드라고할 때,
    - h("abcde") = 97 * 8 + 98 * 4 + 99 * 2 + 100 * 1
    - h("bcdef") = 98 * 8 + 99 * 4 + 100 * 2 + 101 * 1
    - h("bcdef") = (h("abcde") - 97*8)*2 + 101 * 1 //최고차 항 빼고 * 2 + 마지막 항
    - 이런 방법으로 이전의 해시값을 알고 있다면, 다음 해시값을 구하는 과정을 O(1)에 진행할 수 있습니다.
    - 따라서 웬만한 경우에 O(NM)을 O(N)으로 진행할 수 있게 됩니다. 
4. 투포인터 : 백준 '중복없는 구간' 공부하기
    - 배열 { 1,3,1,2,4,2,1,3,2,1 }에 대해서 left = 0 , right = 1 을 가리키는 인덱스
    - L부터 R까지 원소 등장을 표시해두고, R을 하나 늘렸을 ,때 이미 방문한 원소이면 L을 이번에 방문한 원소가 나올 때까지 L++.
    - 단 L<=R 조건을 지키면서 하면 더 안전해보임.
5. LIS 공부
    - Longest Increasing Sequence
    - O(N^2) : dp[i]는 v[i]를 반드시 포함하는 LCS의 길이.  dp[i]를 구하기 위해서는 dp[0,i-1]을 확인해야 한다.
    - O(NlogN) : v[i]를 하나씩 vector에 추가한다. v[v.size()-1]보다 크면 push_back, 아니면 lower_bound(x)로 return되는 위치에 값을 넣는다. 
6. LCS 공부
    - Longest Commen Sequence
    - 두 문자열이 주어졌을 때 임의의 위치에서 문자를 지우고 남은 부분 수열의 최대 길이를 구하는 문제.
    - 문제의 정의에 따라서 문자열에서 "연속된" 가장 긴 문자열의 길이를 구하는 것은 불가능하다.
    - 문자열 A[0,i], B[0,j]에 대해 A[i+1] B[j+1]가 같으면 table[r][c] = table[r-1][c-1]+1, 
    아니라면 table[r][c] = MAX(table[r-1][c], table[r][c-1]) 
7. N!이 2 몇 개로 나누어 지는가?
    - O(NlogN) : i = [1,N]에 대해서 2로 나눌 수 없을 때까지 나눠서 count를 더하면 된다. log2를 취해서 그 값을 더하는 것은 log_2(3)은 2로 나누어떨어질 수 없는데 log_2(3)은 1이상이므로 1번으로 count되는 등 문제가 발생한다. 즉,  일일이 2로 나누어야 한다.
    - O(logN) : 1~N까지 2의 배수는 N/2개, 4의 배수는 N/4개, ... 가 존재한다. 따라서 N/2 + N/4 + ... + N/N보다 작은 가장 큰 2의 제곱승
8. 소인수 분해 : O(logN)
    - N!에 대해서 소인수분해를 하는 문제를 N에 대한 소인수분해 문제로 바꿔서 생각해보자.
    - {N/2 + N/4 + ... + N/N보다 작은 가장 큰 2의 제곱승}이 식을 생각하면 N을 구성하는 인수 2가 몇개인지 알 수 있다.
    - 에라토스테네스의 체를 사용해서 소수를 걸러내고, 소인수는 소수만 올 수 있으므로 위 식을 N까지 소수가 존재하는 갯수만큼 진행하면 된다.
    - O(N까지 소수의 갯수 * logN) = O(logN)
9. N의 약수 a,b 중 |a-b|가 최소가 되는 a * b = N인 a,b 구하기
    - 아래와 같이 약수를 구하고 이들의 가운데 값을 구하면 된다. 
    - for(int i=0; i<sqrt(n); i++){
        if(n&i == 0){
            v.push_back(i);
            if(i * i != n) v.push_back(n/i);
        }
    }


# 삼성전자 A+ 준비 방법
1. 알고리즘잡스 기본 커리 
    - 기준 잘하는 사람은 2달, 못하는 사람은 6달째 힘들어함.
    - 문제 숙제 엄청 내주고(첫주는 쉬운거 50개 정도인듯) 혼자 풀어보기. 어떤 문제를 풀면 되는지 알려줌
    - 주 1회, 3시간 ~ 주 2회, 6시간 만나서 질문 / 코드 리뷰
2. 알고리즘잡스 몰입 캠프
    - 쌩초보 :월화목금일 합쳐서 72시간 강의 수강 + 개인 공부
    - 백준 200개 푼 사람 : 매일 6시간 1.5달~2달 예상


